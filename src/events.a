;license:MIT
;(c) 2022 by 4am
;
; functions for keyboard and mouse events
;
; Public functions:
; - WaitForKeyWithTimeout
; - LongWaitForKeyWithTimeout
; - GetNextEvent
; - WaitNextEvent
; - ClearPendingEvents
;

; event codes (public)
kNoEvent = 0
kEventKeypress = 1
kEventMouseMove = 2
kEventClick = 3

;------------------------------------------------------------------------------
; WaitForKeyWithTimeout
; wait for an amount of time, keypress, or mouse click, whichever comes first
;
; in:    A = timeout length (like standard $FCA8 wait routine but slower)
; out:   A = 0
;        X,Y preserved
;        N = 1 if key was pressed to exit early
;        N = 0 if time ran out
;------------------------------------------------------------------------------
WaitForKeyWithTimeout
         sec
@wait1   pha
@wait2   sbc   #1
         bne   @wait2
         pla
         bit   $C000
         bmi   @exit
         bit   WG_MOUSEACTIVE
         bmi   @pollmouse
         ; burn 206 cycles to match how long it would take
         ; to poll the mouse if we had one
         bit   WG_MOUSEACTIVE
         pha
         pla
         jsr   @burn
         jmp   @next
@pollmouse
         jsr   WGPollMouse_MouseIsActive
         bit   gPointerClicked
         bmi   @exit
@next    sbc   #1
         bne   @wait1
@exit    rts
@burn    jsr   +
+        jsr   +
+        jsr   +
+        jsr   +
         rts

;------------------------------------------------------------------------------
; LongWaitForKeyWithTimeout
; wait for a long amount of time, keypress, or mouse click, whichever comes first
;
; in:    X = number of iterations for an A=0 wait loop
; out:   A,X = 0
;        Y preserved
;        N = 1 if key was pressed to exit early
;        N = 0 if time ran out
;------------------------------------------------------------------------------
LongWaitForKeyWithTimeout
         lda   #0
-        jsr   WaitForKeyWithTimeout
         bmi   +
         dex
         bne   -
+        rts

;------------------------------------------------------------------------------
; GetNextEvent
; check for any key, mouse movement, or mouse click, while incrementing
; random seed
;
; in:    none
; out:   X = event code (see above)
;        if X = kEventKeypress, then
;          A = gLastKeyPressed = unaltered key code
;        Y preserved
;        flags clobbered
;------------------------------------------------------------------------------
GetNextEvent
         inc   RNDSEED
         bne   +
         inc   RNDSEED+1
+
         jsr   UpdateFX
         jsr   WGPollMouse
         bit   gPointerClicked       ; TEST BIT 7 ONLY
         bmi   @onClick
         bit   gPointerMoved         ; TEST BIT 7 ONLY
         bmi   @onMouseMove
         lda   KBD
         bmi   @onKeypress
         ldx   #kNoEvent
         rts
@onKeypress
         bit   CLEARKBD
         sta   gLastKeyPressed
         ldx   #kEventKeypress
         rts
@onMouseMove
         clc
         ror   gPointerMoved         ; TEST BIT 7 ONLY
         ldx   #kEventMouseMove
         rts
@onClick
         clc
         ror   gPointerClicked       ; TEST BIT 7 ONLY
         ldx   #kEventClick
         rts

;------------------------------------------------------------------------------
; WaitNextEvent
; wait forever for any key, mouse movement, or mouse click, while incrementing
; random seed
;
; in:    none
; out:   X = event code (see above)
;        if X = kEventKeypress, then
;          A = gLastKeyPressed = unaltered key code
;        Y preserved
;        flags clobbered
;------------------------------------------------------------------------------
WaitNextEvent
         jsr   GetNextEvent
         cpx   #kNoEvent
         bne   @exit
         bit   RNDSEED+1
         bne   WaitNextEvent
         bit   RNDSEED
         bne   WaitNextEvent
@exit    rts

ClearPendingEvents
         bit   CLEARKBD
         lda   #$00
         sta   gPointerMoved
         sta   gPointerClicked
-        rts

FX_LEFT_MARGIN = 5
FX_NOTE_OFFSET = 25
UpdateFX
; preserves Y
         lda   PT3_CHANGED_LINE
         beq   -

         tya
         pha

         ldy   #$27
-
         lda   fxline5, y
         sta   fxline6, y

         lda   fxline4, y
         sta   fxline5, y

         lda   fxline3, y
         sta   fxline4, y

         lda   fxline2, y
         sta   fxline3, y

         lda   fxline1, y
         sta   fxline2, y

         lda   fxline0, y
         sta   fxline1, y

         lda   #$00
         sta   fxline0, y

         dey
         bpl   -

         ldx   #0
         jsr   PrintNote

         ldx   #(NOTE_STRUCT_SIZE*1)   ; Note B
         jsr   PrintNote

         ldx   #(NOTE_STRUCT_SIZE*2)   ; Note C
         jsr   PrintNote

         ldy   #$27
-
         lda   fxline0, y
         sta   $23d0+FX_LEFT_MARGIN, y
         lda   fxline1, y
         sta   $27d0+FX_LEFT_MARGIN, y
         lda   fxline2, y
         sta   $2bd0+FX_LEFT_MARGIN, y
         lda   fxline3, y
         sta   $2fd0+FX_LEFT_MARGIN, y
         lda   fxline4, y
         sta   $33d0+FX_LEFT_MARGIN, y
         lda   fxline5, y
         sta   $37d0+FX_LEFT_MARGIN, y
         lda   fxline6, y
         sta   $3bd0+FX_LEFT_MARGIN, y
         dey
         bpl   -

         lda   #$00
         sta   PT3_CHANGED_LINE

         pla
         tay

         rts

PrintNote
         lda   note_a+NOTE_ENABLED, x
         beq   @exit
         lda   note_a+NOTE_SAMPLE_POSITION, x
         cmp   #4
         beq   +
         cmp   note_a+NOTE_SAMPLE_LOOP, x
         beq   @exit
+
         lda   note_a+NOTE_RAW_INDEX, x
         sec
         sbc   #FX_NOTE_OFFSET
         bpl   +
         lda   #0
+        cmp   #31
         bcc   +
         lda   #31
+
         tay
;         and   #1
;         beq   +
;         lda   #%10001010
;         !byte $2C
;+
         lda   #%00001111
         sta   fxline0, y
         sta   fxline1, y
         sta   fxline2, y
         sta   fxline3, y
         sta   fxline4, y
         sta   fxline5, y
         sta   fxline6, y
@exit    rts

fxline0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
fxline1
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
fxline2
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
fxline3
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
fxline4
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
fxline5
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
fxline6
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0
