;license:MIT
;(c) 2020-2022 by 4am
;
; common assembler macros (6502 compatible)
;

; .hgrlo, .hgr1hi will each be filled with $C0 bytes
; based on routine by John Brooks
; posted on comp.sys.apple2 on 2018-07-11
; https://groups.google.com/d/msg/comp.sys.apple2/v2HOfHOmeNQ/zD76fJg_BAAJ
; clobbers A,X
; preserves Y
!macro BUILD_HGR_LOOKUP_TABLES .hgrlo, .hgr1hi {
         ldx   #0
-        txa
         and   #$F8
         bpl   +
         ora   #5
+        asl
         bpl   +
         ora   #5
+        asl
         asl
         sta   .hgrlo, x
         txa
         and   #7
         rol
         asl   .hgrlo, x
         rol
         ora   #$20
         sta   .hgr1hi, x
         inx
         cpx   #$C0
         bne   -
}

; load the address of .ptr into A (low) and Y (high)
; preserves X
!macro   LDADDR .ptr {
         lda   #<.ptr
         ldy   #>.ptr
}

; load a 16-bit value into A (low) and Y (high)
; preserves X
!macro   LD16 .ptr {
         lda   .ptr
         ldy   .ptr+1
}

; store a 16-bit value from A (low) and Y (high)
; preserves X
!macro   ST16 .ptr {
         sta   .ptr
         sty   .ptr+1
}

; decrement a 16-bit value in A (low) and Y (high)
; preserves X
!macro   DEC16 {
         sec
         sbc   #1
         bcs   +
         dey
+
}

; increment a 16-bit value in A (low) and Y (high)
; preserves X
!macro   INC16 {
         clc
         adc   #1
         bne   +
         iny
+
}

; increment a 16-bit value stored at an address
; preserves A,X,Y
!macro   INCADDR .addr {
         inc   .addr
         bne   +
         inc   .addr+1
+
}

; compare a 16-bit value in A (low) and Y (high) to an absolute address
; preserves A,X,Y
!macro   CMP16ADDR .addr {
         cmp   .addr
         bne   +
         cpy   .addr+1
+
}

; compare a 16-bit value in A (low) and Y (high) to an immediate value
; preserves A,X,Y
!macro   CMP16 .val {
         cmp   #<.val
         bne   +
         cpy   #>.val
+
}

; long-BPL
; preserves A,X,Y
!macro   LBPL .target {
         bmi   +
         jmp   .target
+
}

; long-BNE
; preserves A,X,Y
!macro   LBNE .target {
         beq   +
         jmp   .target
+
}

; long-BCS
; preserves A,X,Y
!macro   LBCS .target {
         bcc   +
         jmp   .target
+
}

; preserves A,X,Y
!macro   READ_ROM_NO_WRITE {
         bit   $C082
}

; use BIT to swallow the following 1-byte opcode
; preserves A,X,Y
!macro   HIDE_NEXT_BYTE {
         !byte $24
}

; use BIT to swallow the following 2-byte opcode
; preserves A,X,Y
!macro   HIDE_NEXT_2_BYTES {
         !byte $2C
}

; preserves A,X,Y
!macro   RTS_IF_KEY {
         bit   $c000
         bpl   +
         rts
+
}

; wait for keypress (for debugging)
; preserves A,X,Y
!macro   DEBUGWAIT {
         bit   $c010
-        bit   $c000
         bpl   -
         bit   $c010
}

; clobbers all registers & flags
!macro   PRINT_AT .str, .vtab, .htab {
         +LDADDR .str
         +ST16 string_ptr
         ldx   #.vtab
         ldy   #.htab
         sty   tile_column
         ldy   #0
         lda   (string_ptr), y
         sta   string_len
         clc
         adc   tile_column
         sta   tile_column
-        ldy   string_len
         lda   (string_ptr), y
         dec   tile_column
         ldy   tile_column
         jsr   DrawLargeCharacter
         dec   string_len
         bne   -
}
