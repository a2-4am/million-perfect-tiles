;license:MIT
;(c) 2022 by 4am
;
; main menu
;
; Public functions:
; - MainMenuEventLoop
;

; Codes returned by event handlers
kStayOnMainMenu = 0
kQuit = 1

kMainMenuMin = 10
kMainMenuCount = 4
.mainMenuSelectedIndex
         !byte 10

kMainMenuKeys                        ; must keep in sync with kMainMenuKeyHandlersLo/Hi arrays
                                     ; except for last byte ($00) which doesn't need an associated handler
                                     ; additionally, first 4 items correspond to the 4 visible menu items, in order
                                     ; (this is used by the Return handler to delegate to the appropriate handler)

         !byte $D0                   ; P
         !byte $C4                   ; D
         !byte $C6                   ; F
         !byte $D1                   ; Q
         !byte $8D                   ; Return
         !byte $8B                   ; up arrow
         !byte $88                   ; left arrow
         !byte $8A                   ; down arrow
         !byte $95                   ; right arrow
         !byte $A0                   ; space
         !byte $F0                   ; p
         !byte $E4                   ; D
         !byte $E6                   ; f
         !byte $F1                   ; q
         !byte $9B                   ; Esc
         !byte $00

kMainMenuKeyHandlersLo
         !byte <MainMenuEventP
         !byte <MainMenuEventD
         !byte <MainMenuEventF
         !byte <MainMenuEventQ
         !byte <MainMenuEventReturn
         !byte <MainMenuEventUp
         !byte <MainMenuEventUp
         !byte <MainMenuEventDown
         !byte <MainMenuEventDown
         !byte <MainMenuEventDown
         !byte <MainMenuEventP
         !byte <MainMenuEventD
         !byte <MainMenuEventF
         !byte <MainMenuEventQ
         !byte <MainMenuEventQ

kMainMenuKeyHandlersHi
         !byte >MainMenuEventP
         !byte >MainMenuEventD
         !byte >MainMenuEventF
         !byte >MainMenuEventQ
         !byte >MainMenuEventReturn
         !byte >MainMenuEventUp
         !byte >MainMenuEventUp
         !byte >MainMenuEventDown
         !byte >MainMenuEventDown
         !byte >MainMenuEventDown
         !byte >MainMenuEventP
         !byte >MainMenuEventD
         !byte >MainMenuEventF
         !byte >MainMenuEventQ
         !byte >MainMenuEventQ

; len(kMainMenuVTABs) == len(kMainMenuHTABs) == len(kMainMenuStringsLo) == len(kMainMenuStringsHi)
; or you will regret this
kMainMenuVTABs
         !byte 1,2,3,4,5,6,7,9,10,11,12,13,14
kMainMenuHTABs
         !byte 6,2,2,2,5,5,6,5,5,5,5,5,5
kMainMenuStringsLo
         !byte <sMainMenuLine1
         !byte <sMainMenuLine2
         !byte <sMainMenuLine3
         !byte <sMainMenuLine4
         !byte <sMainMenuLine5
         !byte <sMainMenuLine6
         !byte <sMainMenuLine7
         !byte <sMainMenuLine8
         ; nothing on line 9
         !byte <sMainMenuLine10
         !byte <sMainMenuLine11
         !byte <sMainMenuLine12
         !byte <sMainMenuLine13
         !byte <sMainMenuLine14
kMainMenuStringsHi
         !byte >sMainMenuLine1
         !byte >sMainMenuLine2
         !byte >sMainMenuLine3
         !byte >sMainMenuLine4
         !byte >sMainMenuLine5
         !byte >sMainMenuLine6
         !byte >sMainMenuLine7
         !byte >sMainMenuLine8
         ; nothing on line 9
         !byte >sMainMenuLine10
         !byte >sMainMenuLine11
         !byte >sMainMenuLine12
         !byte >sMainMenuLine13
         !byte >sMainMenuLine14

;------------------------------------------------------------------------------
; MainMenuEventLoop
; display main menu
;
; in:    C clear if screen is already cleared and menu page is already drawn
;          (will happen if using arrow keys to move selection indicator)
;        C set if full screen clear & redraw is required
;          (will happen the first time called, or
;          if user returns to main menu from any other screen)
; out:   Z = 0
;------------------------------------------------------------------------------
MainMenuEventLoop
         bcc   @loop
         bit   TEXTMODE
         jsr   HidePointer
         jsr   DrawMainMenuBackground
         jsr   DrawMainMenuText
         jsr   ShowPointer
         bit   GFXMODE
@loop
         jsr   GetNextEvent
         cpx   #kEventMouseMove
         beq   @onMouseMove
         cpx   #kEventClick
         beq   @onClick
         cpx   #kEventKeypress
         bne   @loop
         ldx   #0
-        ldy   kMainMenuKeys, x
         beq   @loop                 ; key has no associated handler, so ignore it
         cpy   gLastKeyPressed       ; populated by WaitForKey
         beq   @dispatch
         inx
         bne   -                     ; always branches
@dispatch
         lda   kMainMenuKeyHandlersLo, x
         sta   @j+1
         lda   kMainMenuKeyHandlersHi, x
         sta   @j+2
@j       jsr   $FDFD                 ; SMC
         beq   MainMenuEventLoop
         rts
@onMouseMove
         +LDADDR MainMenuEventMouseMove
         +ST16 @j+1
         jmp   @j
@onClick
         +LDADDR MainMenuEventClick
         +ST16 @j+1
         jmp   @j

MainMenuEventMouseMove
         jsr   MousePositionToLogicalCoordinates
         cpx   #kMainMenuMin
         bcc   StayOnMainMenuNoRefresh
         cpx   #(kMainMenuMin + kMainMenuCount)
         bcs   StayOnMainMenuNoRefresh
         cpy   #5
         bcc   StayOnMainMenuNoRefresh
         cpy   #11
         bcs   StayOnMainMenuNoRefresh
         cpx   .mainMenuSelectedIndex
         beq   StayOnMainMenuNoRefresh
         txa
         pha
         jsr   HidePointer
         jsr   EraseMainMenuSelectionIndicator
         pla
         tax
         jmp   .MainMenuRedrawSelect

MainMenuEventClick
         jsr   ClickPositionToLogicalCoordinates
         cpx   #kMainMenuMin
         bcc   StayOnMainMenuNoRefresh
         cpx   #(kMainMenuMin + kMainMenuCount)
         bcs   StayOnMainMenuNoRefresh
         cpy   #5
         bcc   StayOnMainMenuNoRefresh
         cpy   #11
         bcs   StayOnMainMenuNoRefresh
         stx   .mainMenuSelectedIndex
         ; /!\ execution falls through here to MainMenuEventReturn

MainMenuEventReturn
         ; figure out which menu item is selected and exit via its handler
         ldx   .mainMenuSelectedIndex
         lda   kMainMenuKeyHandlersLo-kMainMenuMin, x
         sta   @crjmp+1
         lda   kMainMenuKeyHandlersHi-kMainMenuMin, x
         sta   @crjmp+2
@crjmp   jmp   $FDFD                 ; SMC

MainMenuEventUp
         jsr   HidePointer
         jsr   EraseMainMenuSelectionIndicator
         dec   .mainMenuSelectedIndex
         ldx   .mainMenuSelectedIndex
         cpx   #kMainMenuMin
         bcs   +
         ldx   #(kMainMenuMin+kMainMenuCount-1)
+        jmp   .MainMenuRedrawSelect

MainMenuEventDown
         jsr   HidePointer
         jsr   EraseMainMenuSelectionIndicator
         inc   .mainMenuSelectedIndex
         ldx   .mainMenuSelectedIndex
         cpx   #(kMainMenuMin+kMainMenuCount)
         bcc   .MainMenuRedrawSelect
         ldx   #kMainMenuMin
.MainMenuRedrawSelect
         jsr   SetMainMenuSelectionIndexAndRedraw
         jsr   ShowPointer
StayOnMainMenuNoRefresh
         ldx   #kStayOnMainMenu      ; Z=1 so caller will stay in main menu event loop
         clc
         rts

MainMenuEventP
         sec
         jsr   SelectSizeEventLoop
StayOnMainMenuWithFullRefresh
         ldx   #kStayOnMainMenu      ; Z=1 so caller will stay in main menu event loop
         sec                         ; C=1 so caller will do a full screen refresh
         rts

MainMenuEventD
         jsr   RunDemo
         jmp   StayOnMainMenuWithFullRefresh

MainMenuEventF
         jsr   AboutPage
         jmp   StayOnMainMenuWithFullRefresh

MainMenuEventQ
         ldx   #kQuit
         rts

DrawMainMenuBackground
OneTimeLoad
         jsr   LoadRandomBoardForTitle ; SMC opcode
         jsr   DrawBoardForTitle
;
; Auto-solve the randomly chosen board.
; This board buffer persists in memory, so coming back to the main menu
; will just show the solved board.
;
@loop
         jsr   FindValidMoveForTitle
         bcc   @draw
         jsr   TransposeBoard        ; reuses board_base_ptr populated by FindValidMoveForTitle
                                     ; preserves all flags and registers
         jsr   FindValidMoveForTitle
         jsr   TransposeBoard        ; reuses board_base_ptr populated by FindValidMoveForTitle
                                     ; preserves all flags and registers
         bcs   @exit                 ; C is from FindValidMoveForTitle
         jsr   SwapXY                ; swap X & Y because we found a move while the board was transposed
@draw
         bit   GFXMODE
         jsr   DrawLargeCharacter
         pha
         jsr   CalculateRowBase
         sta   board_base_ptr
         pla
         sta   (board_base_ptr), y
         bne   @loop                 ; always branches
@exit
         rts

LoadRandomBoardForTitle
         lda   #kTitleBoardSize
         sta   logical_board_size
         lda   RNDSEED+1
         and   #1
         tay
         lda   RNDSEED
         ldx   #>kTitleBoardBuffer
         jsr   nth
         lda   #$2C                  ; BIT opcode
         sta   OneTimeLoad
         rts

DrawMainMenuText
         lda   #12
         sta   row1
-        ldy   row1
         lda   kMainMenuVTABs, y
         sta   VTAB
         lda   kMainMenuHTABs, y
         tax
         lda   kMainMenuStringsLo, y
         pha
         lda   kMainMenuStringsHi, y
         tay
         pla
         jsr   DrawLargeString
         dec   row1
         bpl   -
         ldx   .mainMenuSelectedIndex
         ; /!\ execution falls through here to SetMainMenuSelectionIndexAndRedraw

SetMainMenuSelectionIndexAndRedraw
; in:    X = new selection index
         stx   .mainMenuSelectedIndex
         ldy   kMainMenuHTABs+8
         lda   #$01                  ; selection indicator character
         jmp   DrawLargeCharacter

EraseMainMenuSelectionIndicator
         ldx   .mainMenuSelectedIndex
         ldy   kMainMenuHTABs+8
         lda   #$00                  ; blank character
         jmp   DrawLargeCharacter
