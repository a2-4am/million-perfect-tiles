;license:MIT
;(c) 2022 by 4am
;
; drawing routines for the puzzle board
;

; DrawBoardForTitle
; DrawBoardForUser
; DrawBoardAt
; DrawFocusRectangle
; DrawFocusRectangleAt
; ClearFocusRectangle
; ClearFocusRectangleAt

DrawBoardForTitle
         ldx   #>kTitleBoardBuffer
         +HIDE_NEXT_2_BYTES
         ; /!\ execution falls through here to DrawBoardForUser
DrawBoardForUser
         ldx   #>kUserBoardBuffer
         ; /!\ execution falls through here to DrawBoardAt
DrawBoardAt
; in:    X = high byte of page-aligned board buffer
; out:   all flags and registers clobbered
         stx   board_base_ptr+1
         stx   @a+2
         lda   #$FF
         sta   @a+1
         ldx   #$0F
-        ldy   #$0F
@a       lda   $FDFD                 ; SMC
         and   #$7F
         cmp   #$02
         beq   @draw
         cmp   #$03
         bne   @nodraw
@draw    jsr   DrawLargeCharacter
@nodraw  dec   @a+1
         dey
         bpl   @a
         dex
         bpl   -
         rts

; to draw focus rectangle around a single tile:
; for X in (top row - 2) .., (bottom row + 2) inclusive
;   (X, left byte - 1) OR= 0xC0
;   (X, right byte + 1) OR= 0xC0
; (top row - 2, left byte) = 0xAA
; (top row - 2, right byte) = 0xD5
; (bottom row + 2, left byte) = 0xAA
; (bottom row + 2, right byte) = 0xD5
;
; to remove focus rectangle around a single tile:
; for X in (top row - 2) ... (bottom row + 2) inclusive
;   (X, left byte - 1) AND= 0xBF
;   (X, right byte + 1) AND= 0xBF
; (top row - 2, left byte) = 0x80
; (top row - 2, right byte) = 0x80
; (bottom row + 2, left byte) = 0x80
; (bottom row + 2, right byte) = 0x80

DrawFocusRectangle
         ldx   gFocusedRow
         ldy   gFocusedColumn
DrawFocusRectangleAt
; in:    X = logical row (0x00..0x0F)
;        Y = logical column (0x00..0x0F)
         +LogicalColumnToPhysicalColumn
         sty   HTAB
         ldy   HGR_start_row, x
         dey
         dey                         ; start two rows above tile
         sty   char_row
         ldx   #11
--       sec
-        ldy   char_row
         lda   HGRLO, y
         sta   hgr_base_ptr
         lda   HGRHI, y
         sta   hgr_base_ptr+1
         bcc   +
         clc
         ldy   HTAB
         lda   #$AA                  ; draw horizontal line above and below tile
         sta   (hgr_base_ptr), y
         iny
         lda   #$D5
         sta   (hgr_base_ptr), y
+        ldy   HTAB
         dey
         lda   (hgr_base_ptr), y
         ora   #$C0                  ; draw red line to the left of tile
         sta   (hgr_base_ptr), y
         iny
         iny
         lda   (hgr_base_ptr), y
         ora   #$C0                  ; draw red line to the right of tile
         sta   (hgr_base_ptr), y
         inc   char_row
         dex
         beq   --
         bpl   -
         rts

ClearFocusRectangle
         jsr   GetFocusCoordinates
ClearFocusRectangleAt
; in:    X = logical row (0x00..0x0F)
;        Y = logical column (0x00..0x0F)
         +LogicalColumnToPhysicalColumn
         sty   HTAB
         ldy   HGR_start_row, x
         dey
         dey                         ; start two rows above tile
         sty   char_row
         ldx   #11
--       sec
-        ldy   char_row
         lda   HGRLO, y
         sta   hgr_base_ptr
         lda   HGRHI, y
         sta   hgr_base_ptr+1
         bcc   +
         clc
         ldy   HTAB
         lda   #$80                  ; erase horizontal line above and below tile (these rows are always black)
         sta   (hgr_base_ptr), y
         iny
         sta   (hgr_base_ptr), y
+        ldy   HTAB
         dey
         lda   (hgr_base_ptr), y
         and   #$BF                  ; erase red line to the left of tile
         sta   (hgr_base_ptr), y
         iny
         iny
         lda   (hgr_base_ptr), y
         and   #$BF                  ; erase red line to the right of tile
         sta   (hgr_base_ptr), y
         inc   char_row
         dex
         beq   --
         bpl   -
         rts
