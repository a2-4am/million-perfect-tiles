;license:MIT
;(c) 2022 by 4am
;
; common graphics functions
;
; Public functions:
; - Home
; - WaitForKeyWithTimeout
; - LongWaitForKeyWithTimeout
; - GetNextEvent
; - GridFizzle
;

kEventKeypress = 1
kEventMouseMove = 2
kEventClick = 3

;------------------------------------------------------------------------------
; Home
; clear graphics page 1 without flicker
;
; in:    none, but assumes text screen 1 is clear (this is done at program startup)
; out:   hi-res page 1 cleared
;        text page 1 displayed
;        X preserved
;        A/Y clobbered
;        flags clobbered
;------------------------------------------------------------------------------
Home
         bit   PAGE1
         bit   FULLGFX
         bit   HIRES
         bit   TEXTMODE
         jsr   HidePointer
         ldy   #$00
         lda   #$80
-        sta   $2000, y
         sta   $2100, y
         sta   $2200, y
         sta   $2300, y
         sta   $2400, y
         sta   $2500, y
         sta   $2600, y
         sta   $2700, y
         sta   $2800, y
         sta   $2900, y
         sta   $2A00, y
         sta   $2B00, y
         sta   $2C00, y
         sta   $2D00, y
         sta   $2E00, y
         sta   $2F00, y
         sta   $3000, y
         sta   $3100, y
         sta   $3200, y
         sta   $3300, y
         sta   $3400, y
         sta   $3500, y
         sta   $3600, y
         sta   $3700, y
         sta   $3800, y
         sta   $3900, y
         sta   $3A00, y
         sta   $3B00, y
         sta   $3C00, y
         sta   $3D00, y
         sta   $3E00, y
         sta   $3F00, y
         iny
         bne   -
         jmp   ShowPointer

;------------------------------------------------------------------------------
; WaitForKeyWithTimeout
; wait for an amount of time, keypress, or mouse click, whichever comes first
;
; in:    A = timeout length (like standard $FCA8 wait routine)
; out:   A = 0
;        X/Y preserved
;        N = 1 if key was pressed to exit early
;        N = 0 if time ran out
;------------------------------------------------------------------------------
WaitForKeyWithTimeout
         sec
@wait1   pha
@wait2   sbc   #1
         bne   @wait2
         pla
         bit   $C000
         bmi   @exit
         bit   gPointerClicked
         bmi   @exit
         sbc   #1
         bne   @wait1
@exit    lda   #0
         sta   gPointerClicked
         rts

;------------------------------------------------------------------------------
; LongWaitForKeyWithTimeout
; wait for a long amount of time, keypress, or mouse click, whichever comes first
;
; in:    X = number of iterations for an A=0 wait loop
; out:   A,X = 0
;        Y preserved
;        N = 1 if key was pressed to exit early
;        N = 0 if time ran out
;------------------------------------------------------------------------------
LongWaitForKeyWithTimeout
         lda   #0
-        jsr   WaitForKeyWithTimeout
         bmi   +
         dex
         bne   -
+        rts

;------------------------------------------------------------------------------
; GetNextEvent
; wait forever for any key, mouse movement, or mouse click, while incrementing
; random seed
;
; in:    none
; out:   X = event code (see above)
;        if X = kEventKeypress, then
;          A = gLastKeyPressed = unaltered key code
;        Y preserved
;        flags clobbered
;------------------------------------------------------------------------------
GetNextEvent
         bit   CLEARKBD
-        inc   RNDSEED
         bne   +
         inc   RNDSEED+1
+        bit   gPointerMoved
         bmi   @onMouseMove
         bit   gPointerClicked
         bmi   @onClick
         lda   KBD
         bpl   -
         bit   CLEARKBD
         sta   gLastKeyPressed
         ldx   #kEventKeypress
         rts
@onMouseMove
         lda   #$00
         sta   gPointerMoved
         ldx   #kEventMouseMove
         rts
@onClick
         lda   #$00
         sta   gPointerClicked
         ldx   #kEventClick
         rts

GridFizzle
         ldx   #0
         ldy   #0
; X,Y=0 on entry to LFSR
@loop    txa
@loop1   eor   #$35                  ; LFSR form 0x3500 with period 0x3FFF
         tax                         ; X is LFSR high byte, Y is LFSR low byte
@loop2   txa
         bne   +                     ; ignore if high byte > 0 (absurdly high period instead of a wait loop)
         pha
         tya
         pha
         lsr
         lsr
         lsr
         lsr
         tax
         tya
         and   #$0F
         tay                         ; split LFSR low byte into nibbles and put in X (high nibble) and Y (low nibble)
         jsr   @draw
         pla
         tay
         pla
+        lsr
         tax
         tya
         ror
         tay
         bcc   @loop2                ; C modified by ror
         bne   @loop                 ; Z modified by tay
         txa
         bne   @loop1
         ; /!\ execution falls through here to draw final coordinates (0,0)
@draw    lda   #$00
         jmp   DrawLargeCharacter
