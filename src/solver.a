;license:MIT
;(c) 2022 by 4am
;
; solving routines
;
; - FindInvalidMove
; - FindValidMoveForUser
; - FindValidMove
; - TransposeBoard

; reason codes (public) returned by FindInvalidMove
kInvalid3WhiteInRow          = 0x01
kInvalid3BlueInRow           = 0x02
kInvalidTooManyWhiteInRow    = 0x03
kInvalidTooManyBlueInRow     = 0x04
kInvalidIdenticalRows        = 0x05
kInvalid3WhiteInColumn       = 0x81
kInvalid3BlueInColumn        = 0x82
kInvalidTooManyWhiteInColumn = 0x83
kInvalidTooManyBlueInColumn  = 0x84
kInvalidIdenticalColumns     = 0x85

TILE_MASK = %01111111

kTransposeFocusTypes
         !byte kFocusEntireColumn, kFocusEntireRow, kFocus1x1, kFocus3x1, kFocus1x3

!macro cmp_0 {
         lda   (board_base_ptr), y
}
!macro cmp_and_0 {
         +cmp_0
         and   #TILE_MASK
}
!macro cmp_white {
         +cmp_and_0
         cmp   #kWhiteTile
}
!macro cmp_blue {
         +cmp_and_0
         cmp   #kBlueTile
}

FindInvalidMoveForUser
         ldx   #>kUserBoardBuffer
         ldy   gLastSelectedBoardSize
         ; /!\ execution falls through here to FindInvalidMove

;------------------------------------------------------------------------------
; FindInvalidMove
; find a tile, row, or column that does not adhere to game rules
;
; in:    X = high byte of page-aligned board buffer
;        Y = logical board size (6,8,10,12,14,16)
; out:   C = 0 if found invalid move, then
;          A = reason code (see above)
;          Z set by A
;          X = starting tile row (0x00..0x0F)
;          Y = starting tile column (0x00..0x0F)
;        C = 1 if no invalid move found
;------------------------------------------------------------------------------
FindInvalidMove
         stx   board_base_ptr+1
         sty   logical_board_size
         ldx   #$0F                  ; tile row
@CheckRow
         +CalculateRowBase
         sta   board_base_ptr
         ldy   #$0D
         sty   tile_column
@CheckTile
         ldy   tile_column
         +cmp_white
         bne   @not2xx
         iny
         +cmp_white
         bne   @nomatch
         iny
         +cmp_white
         bne   @nomatch
         ldy   tile_column
         lda   #kInvalid3WhiteInRow
         clc
@exit    rts
@not2xx
         +cmp_blue
         bne   @nomatch
         iny
         +cmp_blue
         bne   @nomatch
         iny
         +cmp_blue
         bne   @nomatch
         ldy   tile_column
         lda   #kInvalid3BlueInRow
         clc
         rts
@nomatch
         dec   tile_column
         bpl   @CheckTile
         jsr   @DoesRowHaveTooManyOfOneColor
         bcc   @exit
         dex
         bpl   @CheckRow
         jsr   CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
;IsAnyFullRowADuplicateOfAnotherRow
         jsr   CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         +CalculateRowBase
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         bne   @nextrow2
         ; found another full row
         +CalculateRowBase
         sta   board_base_ptr2
         ldx   #0
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         cmp   #kPadding
         bcs   +
         and   #TILE_MASK
         sta   tmpx
         lda   (board_base_ptr), y
         cmp   #kPadding
         bcs   +
         and   #TILE_MASK
         cmp   tmpx
         bne   @nextrow2
         inx
+        dey
         bpl   @comparerowsloop
         txa
         beq   @nextrow2
         ldx   row1
         ldy   row2
         lda   #kInvalidIdenticalRows
         clc
         rts
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

@DoesRowHaveTooManyOfOneColor
         jsr   CountColorsInRow
         lda   colorcount2
         asl
         cmp   logical_board_size
         beq   @notTooMany2
         bcc   @notTooMany2
         ldy   #0
         lda   #kInvalidTooManyWhiteInRow
         clc
         rts
@notTooMany2
         lda   colorcount3
         asl
         cmp   logical_board_size
         beq   @notTooMany3
         bcc   @notTooMany3
         ldy   #0
         lda   #kInvalidTooManyBlueInRow
         clc
         rts
@notTooMany3
         sec
         rts

FindValidMoveForUser
         ldx   #>kUserBoardBuffer
         jsr   TransposeBoardIntoBackupBuffer
         ldx   #>kUserBoardBuffer
         stx   board_base_ptr_original
         lda   #$48                  ; PHA opcode
         sta   FindValidRule1_SetExtendedInfo_Patch
         ldy   #0
         sty   start_y
         ldy   gLastSelectedBoardSize
         sty   logical_board_size
         ; /!\ execution falls through here to FindValidMove

;------------------------------------------------------------------------------
; FindValidMove
; find empty coordinates where a tile could be placed in accordance with
; game rules, based on current board state
;
; in:    $board_base_ptr_original = high byte of board buffer
;        $logical_board_size = logical board size (6,8,10,12,14,16)
;        $kTransposedBoardBuffer contains a copy of the board buffer but transposed
; out:   C = 0 if found valid move, then
;          A = tile value (0x02 or 0x03)
;          X = tile row (0x00..0x0F)
;          Y = tile column (0x00..0x0F)
;        extended information is available in zero page to help the caller
;        draw a focus rectangle:
;          $extended_message
;          $extended_x
;          $extended_y
;          $extended_type
;        C = 1 if no valid move found
;------------------------------------------------------------------------------
FindValidMove
         ldx   board_base_ptr_original
         jsr   FindValidRule1
         bcc   @foundInOriginal

         ldx   #>kTransposedBoardBuffer
         jsr   FindValidRule1
         bcc   @foundInTransposed

         ldx   board_base_ptr_original
         jsr   FindValidRule2
         bcc   @foundInOriginal

         ldx   #>kTransposedBoardBuffer
         jsr   FindValidRule2
         bcc   @foundInTransposed

         ldx   board_base_ptr_original
         jsr   FindValidRule3
         bcc   @foundInOriginal

         ldx   #>kTransposedBoardBuffer
         jsr   FindValidRule3
         bcc   @foundInTransposed
         ; /!\ execution falls through here, but with C=1
@foundInOriginal
         rts
@foundInTransposed
         stx   tmpx
         sty   tmpy
         ldy   extended_x
         ldx   extended_y
         stx   extended_x
         sty   extended_y
         ldx   extended_type
         ldy   kTransposeFocusTypes, x
         sty   extended_type
         ldx   tmpy                  ; X/Y swapped
         ldy   tmpx
         rts

;------------------------------------------------------------------------------
; TransposeBoard
; transpose game board (like a matrix, so rows become columns and
; columns become rows)
;
; in:    board_base_ptr+1 populated with high byte of page-aligned board buffer
; out:   all flags & registers preserved
;------------------------------------------------------------------------------
TransposeBoard
         php
         +SAVE_AXY

         lda   board_base_ptr+1
         sta   @a+2
         sta   @b+2
         sta   @c+2
         sta   @d+2

         ldy   #$00
         ldx   #$00
@a       lda   $FD00, y              ; SMC
         pha
@b       lda   $FD00, x              ; SMC
@c       sta   $FD00, y              ; SMC
         pla
@d       sta   $FD00, x              ; SMC
         txa
         clc
         adc   #$10
         tax
         bcc   +
         iny
         beq   ++
         sty   tmpy
         inx
         txa
         clc
         adc   tmpy
         tax
         tay
         dey
+        iny
         bne   @a
++
         +RESTORE_AXY
         plp
         rts

TransposeBoardIntoBackupBuffer
; transposes game board into kTransposedBoardBuffer
; in:    X = high byte of page-aligned board buffer
; out:   all registers & flags clobbered
;        $tmpy clobbered
         stx   @a+2
         stx   @b+2
         ldx   #$00
         ldy   #$00
@a       lda   $FD00, y              ; SMC
         pha
@b       lda   $FD00, x              ; SMC
         sta   kTransposedBoardBuffer, y
         pla
         sta   kTransposedBoardBuffer, x
         txa
         clc
         adc   #$10
         tax
         bcc   +
         iny
         beq   ++
         sty   tmpy
         inx
         txa
         clc
         adc   tmpy
         tax
         tay
         dey
+        iny
         bne   @a
++       rts

;------------------------------------------------------------------------------
; private

; TODO move this out of program space and build it at runtime
!align 255,0
maybe_xx0
         !byte $FF
maybe_x0x
         !byte     $FF
maybe_0xx
         !byte         $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
         !byte $FF,$FF

FindValidRule1
; find a tile in any row that must be a certain color due to the
; no-3-in-a-row rule
; in:    X = high byte of page-aligned board buffer
; out:   C = 0 if tile was found (+ all the things listed in FindValidMove)
;        C = 1 if no tile was found
         stx   board_base_ptr+1
         stx   board_base_shift_plus_1+1
         stx   board_base_shift_plus_2+1
         dex
         stx   board_base_shift_minus_1+1
         stx   board_base_shift_minus_2+1
         ldx   #0
         stx   board_base_ptr
         ldy   start_y
@loop
         dey
         lda   (board_base_ptr), y
         beq   @found_empty
@next_tile
         dex
         bne   @loop
@no_tile_found
         sec
         rts
@found_empty
         lda   maybe_xx0, y
         bne   @not_xx0
         lda   (board_base_shift_minus_1), y
         beq   @not_xx0
         and   #TILE_MASK
         sta   tile_a
         lda   (board_base_shift_minus_2), y
         and   #TILE_MASK
         cmp   tile_a
         beq   @tile_found_shift_minus_2
@not_xx0
         lda   maybe_x0x, y
         bne   @not_x0x
         lda   (board_base_shift_minus_1), y
         beq   @not_x0x
         and   #TILE_MASK
         sta   tile_a
         lda   (board_base_shift_plus_1), y
         and   #TILE_MASK
         cmp   tile_a
         beq   @tile_found_shift_minus_1
@not_x0x
         lda   maybe_0xx, y
         bne   @next_tile
         lda   (board_base_shift_plus_1), y
         beq   @next_tile
         and   #TILE_MASK
         sta   tile_a
         lda   (board_base_shift_plus_2), y
         and   #TILE_MASK
         cmp   tile_a
         bne   @next_tile
         ldx   #$00
         beq   @tile_found           ; always branches
@tile_found_shift_minus_2
         ldx   #$FE
         bne   @tile_found           ; always branches
@tile_found_shift_minus_1
         ldx   #$FF
@tile_found
         stx   y_shift
         sty   start_y
         eor   #(kWhiteTile XOR kBlueTile)
         pha
         jsr   YIndexToXYCoordinates
         pla
FindValidRule1_SetExtendedInfo_Patch
         pha                         ; SMC
         lda   #<sNever
         sta   extended_message
         lda   #>sNever
         sta   extended_message+1
         lda   #kFocus1x3
         sta   extended_type
         stx   extended_x
         sty   extended_y
         lda   extended_y
         ;C=0 here (set in YIndexToXYCoordinates)
         adc   y_shift
         sta   extended_y
         pla
         clc
         rts

FindValidRule2
; find a tile in any row that must be a certain color due to the
; equal-colors-in-each-row rule
; in:    X = high byte of page-aligned board buffer
; out:   C = 0 if tile was found (+ all the things listed in FindValidMove)
;        C = 1 if no tile was found
         stx   board_base_ptr+1
         ldx   #$0F                  ; tile row
@CheckRow
         +CalculateRowBase
         sta   board_base_ptr
         jsr   CountColorsInRow
         lda   colorcount2
         cmp   colorcount3
         beq   @no                   ; if color counts are the same, we're done (and the answer is no)
         asl
         cmp   logical_board_size
         beq   @fullOf2
         lda   colorcount3
         asl
         cmp   logical_board_size
         beq   @fullOf3
@no
         dex
         bpl   @CheckRow
         sec
         rts
@fullOf2
         lda   #kBlueTile
         +HIDE_NEXT_2_BYTES
@fullOf3
         lda   #kWhiteTile
         pha
         ldy   #$0F
-        lda   (board_base_ptr), y
         beq   @yes
         dey
         bpl   -                     ; always branches
@yes
         lda   #<sSame
         sta   extended_message
         lda   #>sSame
         sta   extended_message+1
         lda   #kFocusEntireRow
         sta   extended_type
         stx   extended_x
         sty   extended_y
         pla                         ; A=tile value, X/Y = row/column
+        clc
         rts

FindValidRule3
; find a tile in any row that must be a certain color due to the
; no-duplicate-rows rule
; in:    X = high byte of page-aligned board buffer
; out:   C = 0 if tile was found (+ all the things listed in FindValidMove)
;        C = 1 if no tile was found
         stx   board_base_ptr+1
         stx   board_base_ptr2+1
         jsr   CountEmptyPerRow
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         +CalculateRowBase
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         cmp   #2
         bne   @nextrow2
         ; found a row with 2 empty tiles
         stx   extended_x
         +CalculateRowBase
         sta   board_base_ptr2
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         beq   +
         and   #TILE_MASK
         sta   tmpx
         lda   (board_base_ptr), y
         and   #TILE_MASK
         cmp   tmpx
         bne   @nextrow2
+        dey
         bpl   @comparerowsloop
         ; row with 2 empty tiles is identical to the full row (except for the 2 empty tiles)
         ; so we can fill one of the empty tiles with the opposite of that column in the full row
         ; since no two rows can be completely identical
         ldy   #$0F
@findemptyloop
         lda   (board_base_ptr2), y
         bne   @nextempty
         lda   (board_base_ptr), y
         and   #TILE_MASK
         cmp   #kWhiteTile
         beq   @makeit3
         lda   #kWhiteTile
         +HIDE_NEXT_2_BYTES
@makeit3 lda   #kBlueTile
         pha
         lda   #<sUnique
         sta   extended_message
         lda   #>sUnique
         sta   extended_message+1
         lda   #kFocusEntireRow
         sta   extended_type
         sty   extended_y
         pla
         clc
         rts
@nextempty
         dey
         bpl   @findemptyloop
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

CountColorsInRow
         lda   #$00
         sta   colorcount2
         sta   colorcount3
         ldy   #$0F
-        lda   (board_base_ptr), y
         and   #TILE_MASK
         cmp   #kWhiteTile
         beq   @inc2
         cmp   #kBlueTile
         beq   @inc3
         dey
         bpl   -
         rts
@inc2    inc   colorcount2
         dey
         bpl   -
         rts
@inc3    inc   colorcount3
         dey
         bpl   -
         rts

CountEmptyPerRow
         ldx   #$0E
         stx   row1
         inx
         ; count number of empty tiles in each row
         ldy   #$00
-        sty   row_empty_counts, x
         dex
         bpl   -
         inx
         ;X=0
         stx   board_base_ptr
         ;Y=0
--       lda   #$10
         sta   tile_column
-        lda   (board_base_ptr), y
         bne   +
         inc   row_empty_counts, x
+        iny
         dec   tile_column
         bne   -
         inx
         tya
         bne   --
         rts
