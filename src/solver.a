;license:MIT
;(c) 2022 by 4am
;
; solving routines
;
; - FindEmptyCoordinatesForUser
; - FindEmptyCoordinates
; - FindInvalidMove
; - FindValidMoveForUser
; - FindValidMove
; - TransposeBoard

; reason codes (public) returned by FindInvalidMove
kInvalid3WhiteInRow          = 0x01
kInvalid3BlueInRow           = 0x02
kInvalidTooManyWhiteInRow    = 0x03
kInvalidTooManyBlueInRow     = 0x04
kInvalidIdenticalRows        = 0x05
kInvalid3WhiteInColumn       = 0x81
kInvalid3BlueInColumn        = 0x82
kInvalidTooManyWhiteInColumn = 0x83
kInvalidTooManyBlueInColumn  = 0x84
kInvalidIdenticalColumns     = 0x85

!macro iny_and_cmp_0 {
         iny
         +cmp_0
}
!macro cmp_0 {
         lda   (board_base_ptr), y
         and   #$7F
}
!macro dey_and_cmp_2 {
         dey
         +cmp_2
}
!macro iny_and_cmp_2 {
         iny
         +cmp_2
}
!macro cmp_2 {
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #kWhiteTile
}
!macro dey_and_cmp_3 {
         dey
         +cmp_3
}
!macro iny_and_cmp_3 {
         iny
         +cmp_3
}
!macro cmp_3 {
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #kBlueTile
}

FindEmptyCoordinatesForUser
         ldx   #>kUserBoardBuffer
         ; /!\ execution falls through here to FindEmptyCoordinates

;------------------------------------------------------------------------------
; FindEmptyCoordinates
; find the top-left-most board coordinates with no tile
;
; in:    X = high byte of page-aligned board buffer
; out:   C = 0 if found empty coordinates, then
;          X = logical row (0x00..0x0F)
;          Y = logical column (0x00..0x0F)
;        C = 1 if no empty coordinates found (board is full)
;------------------------------------------------------------------------------
FindEmptyCoordinates
         stx   board_base_ptr+1
         ldy   #0
         sty   board_base_ptr
-        lda   (board_base_ptr), y
         beq   +
         iny
         bne   -
         sec
         rts
+        tya
         lsr
         lsr
         lsr
         lsr
         tax
         tya
         and   #$0F
         tay
         clc
         rts

FindInvalidMoveForUser
         ldx   #>kUserBoardBuffer
         ldy   gLastSelectedBoardSize
         ; /!\ execution falls through here to FindInvalidMove

;------------------------------------------------------------------------------
; FindInvalidMove
; find a tile, row, or column that does not adhere to game rules
;
; in:    X = high byte of page-aligned board buffer
;        Y = logical board size (6,8,10,12,14,16)
; out:   C = 0 if found invalid move, then
;          A = reason code (see above)
;          Z set by A
;          X = starting tile row (0x00..0x0F)
;          Y = starting tile column (0x00..0x0F)
;        C = 1 if no invalid move found
;------------------------------------------------------------------------------
FindInvalidMove
         stx   board_base_ptr+1
         sty   logical_board_size
         ldx   #$0F                  ; tile row
@CheckRow
         +CalculateRowBaseInline
         sta   board_base_ptr
         ldy   #$0D
         sty   tile_column
@CheckTile
         ldy   tile_column
         +cmp_2
         bne   @not2xx
         +iny_and_cmp_2
         bne   @nomatch
         +iny_and_cmp_2
         bne   @nomatch
         ldy   tile_column
         lda   #kInvalid3WhiteInRow
         clc
@exit    rts
@not2xx
         +cmp_3
         bne   @nomatch
         +iny_and_cmp_3
         bne   @nomatch
         +iny_and_cmp_3
         bne   @nomatch
         ldy   tile_column
         lda   #kInvalid3BlueInRow
         clc
         rts
@nomatch
         dec   tile_column
         bpl   @CheckTile
         jsr   @DoesRowHaveTooManyOfOneColor
         bcc   @exit
         dex
         bpl   @CheckRow
         jsr   CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
;IsAnyFullRowADuplicateOfAnotherRow
         jsr   CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         +CalculateRowBaseInline
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         bne   @nextrow2
         ; found another full row
         +CalculateRowBaseInline
         sta   board_base_ptr2
         ldx   #0
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         and   #$7F
         cmp   #$7F
         beq   +
         sta   tmpx
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #$7F
         beq   +
         cmp   tmpx
         bne   @nextrow2
         inx
+        dey
         bpl   @comparerowsloop
         txa
         beq   @nextrow2
         ldx   row1
         ldy   row2
         lda   #kInvalidIdenticalRows
         clc
         rts
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

@DoesRowHaveTooManyOfOneColor
         jsr   CountColorsInRow
         lda   colorcount2
         asl
         cmp   logical_board_size
         beq   @notTooMany2
         bcc   @notTooMany2
         ldy   #0
         lda   #kInvalidTooManyWhiteInRow
         clc
         rts
@notTooMany2
         lda   colorcount3
         asl
         cmp   logical_board_size
         beq   @notTooMany3
         bcc   @notTooMany3
         ldy   #0
         lda   #kInvalidTooManyBlueInRow
         clc
         rts
@notTooMany3
         sec
         rts

FindValidMoveForUser
         ldx   #>kUserBoardBuffer
         jsr   TransposeBoardIntoBackupBuffer
         ldx   #>kUserBoardBuffer
         stx   board_base_ptr_original
         ldy   gLastSelectedBoardSize
         sty   logical_board_size
         ; /!\ execution falls through here to FindValidMove

;------------------------------------------------------------------------------
; FindValidMove
; find empty coordinates where a tile could be placed in accordance with
; game rules, based on current board state
;
; in:    $board_base_ptr_original = high byte of board buffer
;        $logical_board_size = logical board size (6,8,10,12,14,16)
;        kTransposedBoardBuffer contains a copy of the board buffer but transposed
; out:   C = 0 if found valid move, then
;          A = tile value (0x02 or 0x03)
;          X = tile row (0x00..0x0F)
;          Y = tile column (0x00..0x0F)
;        extended information is available in zero page to help the caller
;        draw a focus rectangle:
;          $extended_message
;          $extended_x
;          $extended_y
;          $extended_type
;        C = 1 if no valid move found
;------------------------------------------------------------------------------
FindValidMove
         ldx   board_base_ptr_original
         jsr   FindValidRule1
         bcc   @foundInOriginal

         ldx   #>kTransposedBoardBuffer
         jsr   FindValidRule1
         bcc   @foundInTransposed

         ldx   board_base_ptr_original
         jsr   FindValidRule2
         bcc   @foundInOriginal

         ldx   #>kTransposedBoardBuffer
         jsr   FindValidRule2
         bcc   @foundInTransposed

         ldx   board_base_ptr_original
         jsr   FindValidRule3
         bcc   @foundInOriginal

         ldx   #>kTransposedBoardBuffer
         jsr   FindValidRule3
         bcc   @foundInTransposed
         ; /!\ execution falls through here, but with C=1
@foundInOriginal
         rts
@foundInTransposed
         jsr   TransposeExtendedInfo
         jmp   SwapXY                ; swap X & Y because we found a move while the board was transposed

;------------------------------------------------------------------------------
; TransposeBoard
; transpose game board (like a matrix, so rows become columns and
; columns become rows)
;
; in:    board_base_ptr+1 populated with high byte of page-aligned board buffer
; out:   all flags & registers preserved
;------------------------------------------------------------------------------
TransposeBoard
         php
         +SAVE_AXY

         lda   board_base_ptr+1
         sta   @a+2
         sta   @b+2
         sta   @c+2
         sta   @d+2

         ldy   #$00
         ldx   #$00
@a       lda   $FD00, y              ; SMC
         pha
@b       lda   $FD00, x              ; SMC
@c       sta   $FD00, y              ; SMC
         pla
@d       sta   $FD00, x              ; SMC
         txa
         clc
         adc   #$10
         tax
         bcc   +
         iny
         beq   ++
         sty   tmpy
         inx
         txa
         clc
         adc   tmpy
         tax
         tay
         dey
+        iny
         bne   @a
++
         +RESTORE_AXY
         plp
         rts

TransposeBoardIntoBackupBuffer
; transposes game board into kTransposedBoardBuffer
; in:    X = high byte of page-aligned board buffer
; out:   all registers & flags clobbered
;        $tmpy clobbered
         stx   @a+2
         stx   @b+2
         ldx   #>kTransposedBoardBuffer
         stx   @c+2
         stx   @d+2
         ldx   #$00
         ldy   #$00
@a       lda   $FD00, y              ; SMC
         pha
@b       lda   $FD00, x              ; SMC
@c       sta   $FD00, y              ; SMC
         pla
@d       sta   $FD00, x              ; SMC
         txa
         clc
         adc   #$10
         tax
         bcc   +
         iny
         beq   ++
         sty   tmpy
         inx
         txa
         clc
         adc   tmpy
         tax
         tay
         dey
+        iny
         bne   @a
++       rts

;------------------------------------------------------------------------------
; private

FindValidRule1
; find a tile in any row that must be a certain color due to the
; no-3-in-a-row rule
; in:    X = high byte of page-aligned board buffer
         stx   board_base_ptr+1
         ldx   #$0F                  ; tile row
@CheckRow
         +CalculateRowBaseInline
         sta   board_base_ptr
         ldy   #$0D
         sty   tile_column
@CheckTile
         ldy   tile_column
         +cmp_0
         bne   @not0xx
         +iny_and_cmp_2
         bne   @not02x
         +iny_and_cmp_2
         +LBNE @nomatch
         ;found 022, valid move to change 0 -> 3
         jsr   SetExtendedInfoFor1x3
         lda   #kBlueTile
-        ldy   tile_column
         clc
         rts
@not02x
         cmp   #kBlueTile
         +LBNE @nomatch
         +iny_and_cmp_3
         +LBNE @nomatch
         ;found 033, valid move to change 0 -> 2
         jsr   SetExtendedInfoFor1x3
         lda   #kWhiteTile
         bne   -                     ; always branches
@not0xx
         +iny_and_cmp_0
         bne   @notx0x
         dey
         +cmp_2
         bne   @not20x
         iny
         +iny_and_cmp_2
         bne   @nomatch
         ;found 202, valid move to change 0 -> 3
         jsr   SetExtendedInfoFor1x3
         lda   #kBlueTile
-        ldy   tile_column
         iny
         clc
         rts
@not20x
         cmp   #kBlueTile
         bne   @nomatch
         iny
         +iny_and_cmp_3
         bne   @nomatch
         ;found 303, valid move to change 0 -> 2
         jsr   SetExtendedInfoFor1x3
         lda   #kWhiteTile
         bne   -                     ; always branches
@notx0x
         +iny_and_cmp_0
         bne   @nomatch
         +dey_and_cmp_2
         bne   @notx20
         +dey_and_cmp_2
         bne   @nomatch
         ;found 220, valid move to change 0 -> 3
         jsr   SetExtendedInfoFor1x3
         lda   #kBlueTile
-        ldy   tile_column
         iny
         iny
         clc
@exit    rts
@notx20
         cmp   #kBlueTile
         bne   @nomatch
         +dey_and_cmp_3
         bne   @nomatch
         ;found 330, valid move to change 0 -> 2
         jsr   SetExtendedInfoFor1x3
         lda   #kWhiteTile
         bne   -                     ; always branches
@nomatch
         dec   tile_column
         +LBPL @CheckTile
         dex
         +LBPL @CheckRow
         sec
         rts

FindValidRule2
; find a tile in any row that must be a certain color due to the
; equal-colors-in-each-row rule
; in:    X = high byte of page-aligned board buffer
         stx   board_base_ptr+1
         ldx   #$0F                  ; tile row
@CheckRow
         +CalculateRowBaseInline
         sta   board_base_ptr
         jsr   CountColorsInRow
         lda   colorcount2
         cmp   colorcount3
         beq   @no                   ; if color counts are the same, we're done (and the answer is no)
         asl
         cmp   logical_board_size
         beq   @fullOf2
         lda   colorcount3
         asl
         cmp   logical_board_size
         beq   @fullOf3
@no
         dex
         bpl   @CheckRow
         sec
         rts
@fullOf2
         lda   #kBlueTile
         +HIDE_NEXT_2_BYTES
@fullOf3
         lda   #kWhiteTile
         pha
         ldy   #$0F
-        lda   (board_base_ptr), y
         beq   @yes
         dey
         bpl   -                     ; always branches
@yes
         lda   #<sSame
         sta   extended_message
         lda   #>sSame
         sta   extended_message+1
         lda   #kFocusEntireRow
         sta   extended_type
         stx   extended_x
         sty   extended_y
         pla                         ; A=tile value, X/Y = row/column
+        clc
         rts

FindValidRule3
; find a tile in any row that must be a certain color due to the
; no-duplicate-rows rule
; in:    X = high byte of page-aligned board buffer
         stx   board_base_ptr+1
         stx   board_base_ptr2+1
         jsr   CountEmptyPerRow
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         +CalculateRowBaseInline
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         cmp   #2
         bne   @nextrow2
         ; found a row with 2 empty tiles
         stx   extended_x
         +CalculateRowBaseInline
         sta   board_base_ptr2
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         beq   +
         and   #$7F
         sta   tmpx
         lda   (board_base_ptr), y
         and   #$7F
         cmp   tmpx
         bne   @nextrow2
+        dey
         bpl   @comparerowsloop
         ; row with 2 empty tiles is identical to the full row (except for the 2 empty tiles)
         ; so we can fill one of the empty tiles with the opposite of that column in the full row
         ; since no two rows can be completely identical
         ldy   #$0F
@findemptyloop
         lda   (board_base_ptr2), y
         bne   @nextempty
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #kWhiteTile
         beq   @makeit3
         lda   #kWhiteTile
         +HIDE_NEXT_2_BYTES
@makeit3 lda   #kBlueTile
         pha
         lda   #<sUnique
         sta   extended_message
         lda   #>sUnique
         sta   extended_message+1
         lda   #kFocusEntireRow
         sta   extended_type
         sty   extended_y
         pla
         clc
         rts
@nextempty
         dey
         bpl   @findemptyloop
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

SetExtendedInfoFor1x3
         +LDADDR sNever
         +ST16 extended_message
         lda   #kFocus1x3
         sta   extended_type
         stx   extended_x
         lda   tile_column
         sta   extended_y
         rts

CountColorsInRow
         lda   #$00
         sta   colorcount2
         sta   colorcount3
         ldy   #$0F
-        +cmp_0
         cmp   #kWhiteTile
         beq   @inc2
         cmp   #kBlueTile
         beq   @inc3
         +HIDE_NEXT_2_BYTES
@inc2    inc   colorcount2
         +HIDE_NEXT_2_BYTES
@inc3    inc   colorcount3
         dey
         bpl   -
         rts

CountEmptyPerRow
         ldx   #$0E
         stx   row1
         inx
         ; count number of empty tiles in each row
         ldy   #$00
-        sty   row_empty_counts, x
         dex
         bpl   -
         inx
         ;X=0
         stx   board_base_ptr
         ;Y=0
--       lda   #$10
         sta   tile_column
-        lda   (board_base_ptr), y
         bne   +
         inc   row_empty_counts, x
+        iny
         dec   tile_column
         bne   -
         inx
         tya
         bne   --
         rts

kTransposeFocusTypes
         !byte kFocusEntireColumn, kFocusEntireRow, kFocus1x1, kFocus3x1, kFocus1x3

TransposeExtendedInfo
; out:   preserves all registers and flags
         php
         +SAVE_AXY
         ldx   extended_x
         txa
         ldx   extended_y
         stx   extended_x
         sta   extended_y
         ldx   extended_type
         lda   kTransposeFocusTypes, x
         sta   extended_type
         +RESTORE_AXY
         plp
         rts
