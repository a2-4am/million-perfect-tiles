;license:MIT
;(c) 2022 by 4am
;
; puzzle solving routines
;

FindValidMove
; in:    board_base_ptr+1 populated with high byte of page-aligned board buffer
; out:   C=0 if found valid move, then
;          A=tile value (1 or 2)
;          X=tile row (0..15)
;          Y=tile column (0..15)
;        C=1 if no valid move was found
         ldx   #$0F                  ; tile row
.CheckRow
         jsr   CalculateRowBase
         sta   board_base_ptr
         ldy   #$0D
         sty   tile_column
.CheckTile
         ldy   tile_column
         jsr   cmp_0
         bne   .not0xx
         jsr   iny_and_cmp_1
         bne   .not01x
         jsr   iny_and_cmp_1
         bne   .nomatch
         ;found 011, valid move to change 0 -> 2
         lda   #$02
-        ldy   tile_column
         clc
         rts
.not01x
         cmp   #$02
         bne   .nomatch
         jsr   iny_and_cmp_2
         bne   .nomatch
         ;found 022, valid move to change 0 -> 1
         lda   #$01
         bne   -                     ; always branches
.not0xx
         jsr   iny_and_cmp_0
         bne   .notx0x
         dey
         jsr   cmp_1
         bne   .not10x
         iny
         jsr   iny_and_cmp_1
         bne   .nomatch
         ;found 101, valid move to change 0 -> 2
         lda   #$02
-        dey
         clc
         rts
.not10x
         cmp   #$02
         bne   .nomatch
         iny
         jsr   iny_and_cmp_2
         bne   .nomatch
         ;found 202, valid move to change 0 -> 1
         lda   #$01
         bne   -                     ; always branches
.notx0x
         jsr   iny_and_cmp_0
         bne   .nomatch
         jsr   dey_and_cmp_1
         bne   .notx10
         jsr   dey_and_cmp_1
         bne   .nomatch
         ;found 110, valid move to change 0 -> 2
         lda   #$02
-        iny
         iny
         clc
.exit    rts
.notx10
         cmp   #$02
         bne   .nomatch
         jsr   dey_and_cmp_2
         bne   .nomatch
         ;found 220, valid move to change 0 -> 1
         lda   #$01
         bne   -                     ; always branches
.nomatch
         dec   tile_column
         bpl   .CheckTile
         jsr   IsRowFullOfOneColorButNotTheOther
         bcc   .exit
         dex
         bpl   .CheckRow
;IsAnyRowAlmostADuplicateOfAnotherRow
         ldx   #$0E
         stx   row1
         inx
         ; count number of empty tiles in each row
         ldy   #$00
-        sty   row_empty_counts, x
         dex
         bpl   -
         inx
         ;X=0
         stx   board_base_ptr
         ;Y=0
--       lda   #$10
         sta   tile_column
-        lda   (board_base_ptr), y
         bne   +
         inc   row_empty_counts, x
+        iny
         dec   tile_column
         bne   -
         inx
         tya
         bne   --
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         jsr   CalculateRowBase
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         cmp   #$02
         bne   @nextrow2
         ; found a row with 2 empty tiles
         jsr   CalculateRowBase
         sta   board_base_ptr2
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         beq   +
         and   #$7F
         sta   tmpx
         lda   (board_base_ptr), y
         and   #$7F
         cmp   tmpx
         bne   @nextrow2
+        dey
         bpl   @comparerowsloop
         ; row with 2 empty tiles is identical to the full row (except for the 2 empty tiles)
         ; so we can fill one of the empty tiles with the opposite of that column in the full row
         ; since no two rows can be completely identical
         ldy   #$0F
@findemptyloop
         lda   (board_base_ptr2), y
         bne   +
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #$01
         beq   @makeit2
         lda   #$01
         +HIDE_NEXT_2_BYTES
@makeit2 lda   #$02
         clc
         rts
+        dey
         bpl   @findemptyloop
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

IsRowFullOfOneColorButNotTheOther
         lda   #$00
         sta   colorcount1
         sta   colorcount2
         ldy   #$0F
-        jsr   cmp_0
         cmp   #$01
         beq   .inc1
         cmp   #$02
         beq   .inc2
         +HIDE_NEXT_2_BYTES
.inc1    inc   colorcount1
         +HIDE_NEXT_2_BYTES
.inc2    inc   colorcount2
         dey
         bpl   -
         lda   colorcount1
         cmp   colorcount2
         beq   .no                   ; if color counts are the same, we're done (and the answer is no)
         asl
         cmp   logical_board_size
         beq   .fullOf1
         lda   colorcount2
         asl
         cmp   logical_board_size
         beq   .fullOf2
.no
         sec
         rts
.fullOf1
         lda   #$02
         +HIDE_NEXT_2_BYTES
.fullOf2
         lda   #$01
         pha
         ldy   #$0F
-        lda   (board_base_ptr), y
         beq   .yes
         dey
         bpl   -                     ; always branches
.yes
         pla                         ; A=1 or 2, X/Y contain row/column
         clc
         rts

iny_and_cmp_0
         iny
cmp_0    lda   (board_base_ptr), y
         and   #$7F
         rts
dey_and_cmp_1
         dey
         +HIDE_NEXT_BYTE
iny_and_cmp_1
         iny
cmp_1    lda   (board_base_ptr), y
         and   #$7F
         cmp   #$01
         rts
dey_and_cmp_2
         dey
         +HIDE_NEXT_BYTE
iny_and_cmp_2
         iny
cmp_2    lda   (board_base_ptr), y
         and   #$7F
         cmp   #$02
         rts

TransposeBoard
; in:    board_base_ptr+1 populated with high byte of page-aligned board buffer
; out:   all flags & registers preserved
         php
         pha
         txa
         pha
         tya
         pha

         lda   board_base_ptr+1
         sta   @a+2
         sta   @b+2
         sta   @c+2
         sta   @d+2

         ldy   #$00
         ldx   #$00
@a       lda   $FD00, y              ; SMC
         pha
@b       lda   $FD00, x              ; SMC
@c       sta   $FD00, y              ; SMC
         pla
@d       sta   $FD00, x              ; SMC
         txa
         clc
         adc   #$10
         tax
         bcc   +
         iny
         beq   ++
         sty   tmpy
         inx
         txa
         clc
         adc   tmpy
         tax
         tay
         dey
+        iny
         bne   @a
++
         pla
         tay
         pla
         tax
         pla
         plp
         rts

CalculateRowBase
; in:    X = row (0..15)
; out:   A = low byte of address of board buffer for this row
         txa
         asl
         asl
         asl
         asl
         rts
