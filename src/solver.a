;license:MIT
;(c) 2022 by 4am
;
; solving routines
;
; - FindEmptyCoordinatesForUser
; - FindEmptyCoordinates
; - FindInvalidMove
; - FindValidMoveForTitle
; - FindValidMoveForUser
; - FindValidMove
; - TransposeBoard

; reason codes (public) returned by FindInvalidMove
kInvalid3WhiteInRow          = 0x01
kInvalid3BlueInRow           = 0x02
kInvalidTooManyWhiteInRow    = 0x03
kInvalidTooManyBlueInRow     = 0x04
kInvalidIdenticalRows        = 0x05
kInvalid3WhiteInColumn       = 0x81
kInvalid3BlueInColumn        = 0x82
kInvalidTooManyWhiteInColumn = 0x83
kInvalidTooManyBlueInColumn  = 0x84
kInvalidIdenticalColumns     = 0x85

FindEmptyCoordinatesForUser
         ldx   #>kUserBoardBuffer
         ; /!\ execution falls through here to FindEmptyCoordinates

;------------------------------------------------------------------------------
; FindEmptyCoordinates
; find the top-left-most board coordinates with no tile
;
; in:    X = high byte of page-aligned board buffer
; out:   C = 0 if found empty coordinates, then
;          X = logical row (0x00..0x0F)
;          Y = logical column (0x00..0x0F)
;        C = 1 if no empty coordinates found (board is full)
;------------------------------------------------------------------------------
FindEmptyCoordinates
         stx   board_base_ptr+1
         ldy   #0
         sty   board_base_ptr
-        lda   (board_base_ptr), y
         beq   +
         iny
         bne   -
         sec
         rts
+        tya
         lsr
         lsr
         lsr
         lsr
         tax
         tya
         and   #$0F
         tay
         clc
         rts

FindInvalidMoveForUser
         ldx   #>kUserBoardBuffer
         ldy   gLastSelectedBoardSize
         ; /!\ execution falls through here to FindInvalidMove

;------------------------------------------------------------------------------
; FindInvalidMove
; find a tile, row, or column that does not adhere to game rules
;
; in:    X = high byte of page-aligned board buffer
;        Y = logical board size (6,8,10,12,14,16)
; out:   C = 0 if found invalid move, then
;          A = reason code (see above)
;          Z set by A
;          X = starting tile row (0x00..0x0F)
;          Y = starting tile column (0x00..0x0F)
;        C = 1 if no invalid move found
;------------------------------------------------------------------------------
FindInvalidMove
         stx   board_base_ptr+1
         sty   logical_board_size
         ldx   #$0F                  ; tile row
@CheckRow
         jsr   CalculateRowBase
         sta   board_base_ptr
         ldy   #$0D
         sty   tile_column
@CheckTile
         ldy   tile_column
         jsr   cmp_2
         bne   @not2xx
         jsr   iny_and_cmp_2
         bne   @nomatch
         jsr   iny_and_cmp_2
         bne   @nomatch
         ldy   tile_column
         lda   #kInvalid3WhiteInRow
         clc
@exit    rts
@not2xx
         jsr   cmp_3
         bne   @nomatch
         jsr   iny_and_cmp_3
         bne   @nomatch
         jsr   iny_and_cmp_3
         bne   @nomatch
         ldy   tile_column
         lda   #kInvalid3BlueInRow
         clc
         rts
@nomatch
         dec   tile_column
         bpl   @CheckTile
         jsr   @DoesRowHaveTooManyOfOneColor
         bcc   @exit
         dex
         bpl   @CheckRow
         jsr   .CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
;IsAnyFullRowADuplicateOfAnotherRow
         jsr   .CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         jsr   CalculateRowBase
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         bne   @nextrow2
         ; found another full row
         jsr   CalculateRowBase
         sta   board_base_ptr2
         ldx   #0
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         and   #$7F
         cmp   #$7F
         beq   +
         sta   tmpx
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #$7F
         beq   +
         cmp   tmpx
         bne   @nextrow2
         inx
+        dey
         bpl   @comparerowsloop
         txa
         beq   @nextrow2
         ldx   row1
         ldy   row2
         lda   #kInvalidIdenticalRows
         clc
         rts
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

@DoesRowHaveTooManyOfOneColor
         jsr   .CountColorsInRow
         lda   colorcount2
         asl
         cmp   logical_board_size
         beq   @notTooMany2
         bcc   @notTooMany2
         ldy   #0
         lda   #kInvalidTooManyWhiteInRow
         clc
         rts
@notTooMany2
         lda   colorcount3
         asl
         cmp   logical_board_size
         beq   @notTooMany3
         bcc   @notTooMany3
         ldy   #0
         lda   #kInvalidTooManyBlueInRow
         clc
         rts
@notTooMany3
         sec
         rts

FindValidMoveForUser
         ldx   #>kUserBoardBuffer
         ldy   gLastSelectedBoardSize
         bne   FindValidMove         ; always branches

FindValidMoveForTitle
         ldx   #>kTitleBoardBuffer
         ldy   #kTitleBoardSize
         ; /!\ execution falls through here to FindValidMove

;------------------------------------------------------------------------------
; FindValidMove
; find empty coordinates where a tile could be placed in accordance with
; game rules, based on current board state
;
; in:    X = high byte of page-aligned board buffer
;        Y = logical board size (6,8,10,12,14,16)
; out:   C = 0 if found valid move, then
;          A = tile value (0x02 or 0x03)
;          X = tile row (0x00..0x0F)
;          Y = tile column (0x00..0x0F)
;        C = 1 if no valid move found
;------------------------------------------------------------------------------
FindValidMove
         stx   board_base_ptr+1
         sty   logical_board_size
         ldx   #$0F                  ; tile row
@CheckRow
         jsr   CalculateRowBase
         sta   board_base_ptr
         ldy   #$0D
         sty   tile_column
@CheckTile
         ldy   tile_column
         jsr   cmp_0
         bne   @not0xx
         jsr   iny_and_cmp_2
         bne   @not02x
         jsr   iny_and_cmp_2
         bne   @nomatch
         ;found 022, valid move to change 0 -> 3
         lda   #$03
-        ldy   tile_column
         clc
         rts
@not02x
         cmp   #$03
         bne   @nomatch
         jsr   iny_and_cmp_3
         bne   @nomatch
         ;found 033, valid move to change 0 -> 2
         lda   #$02
         bne   -                     ; always branches
@not0xx
         jsr   iny_and_cmp_0
         bne   @notx0x
         dey
         jsr   cmp_2
         bne   @not20x
         iny
         jsr   iny_and_cmp_2
         bne   @nomatch
         ;found 202, valid move to change 0 -> 3
         lda   #$03
-        dey
         clc
         rts
@not20x
         cmp   #$03
         bne   @nomatch
         iny
         jsr   iny_and_cmp_3
         bne   @nomatch
         ;found 303, valid move to change 0 -> 2
         lda   #$02
         bne   -                     ; always branches
@notx0x
         jsr   iny_and_cmp_0
         bne   @nomatch
         jsr   dey_and_cmp_2
         bne   @notx20
         jsr   dey_and_cmp_2
         bne   @nomatch
         ;found 220, valid move to change 0 -> 3
         lda   #$03
-        iny
         iny
         clc
@exit    rts
@notx20
         cmp   #$03
         bne   @nomatch
         jsr   dey_and_cmp_3
         bne   @nomatch
         ;found 330, valid move to change 0 -> 2
         lda   #$02
         bne   -                     ; always branches
@nomatch
         dec   tile_column
         bpl   @CheckTile
         jsr   @IsRowFullOfOneColorButNotTheOther
         bcc   @exit
         dex
         bpl   @CheckRow
;IsAnyRowAlmostADuplicateOfAnotherRow
         jsr   .CountEmptyPerRow
         lda   board_base_ptr+1
         sta   board_base_ptr2+1
@row1loop
         ldx   row1
         lda   row_empty_counts, x
         bne   @nextrow1
         ; found a full row
         jsr   CalculateRowBase
         sta   board_base_ptr
         lda   #$0F
         sta   row2
@row2loop
         ldx   row2
         lda   row_empty_counts, x
         cmp   #$02
         bne   @nextrow2
         ; found a row with 2 empty tiles
         jsr   CalculateRowBase
         sta   board_base_ptr2
         ldy   #$0F
@comparerowsloop
         lda   (board_base_ptr2), y
         beq   +
         and   #$7F
         sta   tmpx
         lda   (board_base_ptr), y
         and   #$7F
         cmp   tmpx
         bne   @nextrow2
+        dey
         bpl   @comparerowsloop
         ; row with 2 empty tiles is identical to the full row (except for the 2 empty tiles)
         ; so we can fill one of the empty tiles with the opposite of that column in the full row
         ; since no two rows can be completely identical
         ldy   #$0F
@findemptyloop
         lda   (board_base_ptr2), y
         bne   +
         lda   (board_base_ptr), y
         and   #$7F
         cmp   #$02
         beq   @makeit3
         lda   #$02
         +HIDE_NEXT_2_BYTES
@makeit3 lda   #$03
         clc
         rts
+        dey
         bpl   @findemptyloop
@nextrow2
         dec   row2
         lda   row1
         cmp   row2
         bcc   @row2loop
@nextrow1
         dec   row1
         bpl   @row1loop
         sec
         rts

@IsRowFullOfOneColorButNotTheOther
         jsr   .CountColorsInRow
         lda   colorcount2
         cmp   colorcount3
         beq   @no                   ; if color counts are the same, we're done (and the answer is no)
         asl
         cmp   logical_board_size
         beq   @fullOf2
         lda   colorcount3
         asl
         cmp   logical_board_size
         beq   @fullOf3
@no
         sec
         rts
@fullOf2
         lda   #$03
         +HIDE_NEXT_2_BYTES
@fullOf3
         lda   #$02
         pha
         ldy   #$0F
-        lda   (board_base_ptr), y
         beq   @yes
         dey
         bpl   -                     ; always branches
@yes
         pla                         ; A=1 or 2, X/Y contain row/column
         clc
         rts

;------------------------------------------------------------------------------
; TransposeBoard
; transpose game board (like a matrix, so rows become columns and
; columns become rows)
;
; in:    board_base_ptr+1 populated with high byte of page-aligned board buffer
; out:   all flags & registers preserved
;------------------------------------------------------------------------------
TransposeBoard
         php
         pha
         txa
         pha
         tya
         pha

         lda   board_base_ptr+1
         sta   @a+2
         sta   @b+2
         sta   @c+2
         sta   @d+2

         ldy   #$00
         ldx   #$00
@a       lda   $FD00, y              ; SMC
         pha
@b       lda   $FD00, x              ; SMC
@c       sta   $FD00, y              ; SMC
         pla
@d       sta   $FD00, x              ; SMC
         txa
         clc
         adc   #$10
         tax
         bcc   +
         iny
         beq   ++
         sty   tmpy
         inx
         txa
         clc
         adc   tmpy
         tax
         tay
         dey
+        iny
         bne   @a
++
         pla
         tay
         pla
         tax
         pla
         plp
         rts

;------------------------------------------------------------------------------
; private

.CountColorsInRow
         lda   #$00
         sta   colorcount2
         sta   colorcount3
         ldy   #$0F
-        jsr   cmp_0
         cmp   #$02
         beq   @inc2
         cmp   #$03
         beq   @inc3
         +HIDE_NEXT_2_BYTES
@inc2    inc   colorcount2
         +HIDE_NEXT_2_BYTES
@inc3    inc   colorcount3
         dey
         bpl   -
         rts

.CountEmptyPerRow
         ldx   #$0E
         stx   row1
         inx
         ; count number of empty tiles in each row
         ldy   #$00
-        sty   row_empty_counts, x
         dex
         bpl   -
         inx
         ;X=0
         stx   board_base_ptr
         ;Y=0
--       lda   #$10
         sta   tile_column
-        lda   (board_base_ptr), y
         bne   +
         inc   row_empty_counts, x
+        iny
         dec   tile_column
         bne   -
         inx
         tya
         bne   --
         rts

iny_and_cmp_0
         iny
cmp_0    lda   (board_base_ptr), y
         and   #$7F
         rts
dey_and_cmp_2
         dey
         +HIDE_NEXT_BYTE
iny_and_cmp_2
         iny
cmp_2    lda   (board_base_ptr), y
         and   #$7F
         cmp   #$02
         rts
dey_and_cmp_3
         dey
         +HIDE_NEXT_BYTE
iny_and_cmp_3
         iny
cmp_3    lda   (board_base_ptr), y
         and   #$7F
         cmp   #$03
         rts
